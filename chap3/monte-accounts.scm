(define format
  (lambda (format-string . objects)
    (let ((buffer (open-output-string)))
      (let loop ((format-list (string->list format-string))
                 (objects objects))
        (cond ((null? format-list) (get-output-string buffer))
              ((char=? (car format-list) #\~)
               (if (null? (cdr format-list))
                   (error 'format "Incomplete escape sequence")
                   (case (cadr format-list)
                     ((#\a)
                      (if (null? objects)
                          (error 'format "No value for escape sequence")
                          (begin
                            (display (car objects) buffer)
                            (loop (cddr format-list) (cdr objects)))))
	             ((#\s)
                      (if (null? objects)
                          (error 'format "No value for escape sequence")
                          (begin
                            (write (car objects) buffer)
                            (loop (cddr format-list) (cdr objects)))))
                     ((#\%)
                      (newline buffer)
                      (loop (cddr format-list) objects))
                     ((#\~)
                      (write-char #\~ buffer)
                      (loop (cddr format-list) objects))
                     (else
                      (error 'format "Unrecognized escape sequence")))))
              (else (write-char (car format-list) buffer)
                    (loop (cdr format-list) objects)))))))

(define (make-accum accumulated)
  (define (accum amount)
    (set! accumulated (+ accumulated amount))
    (display accumulated)
    accumulated)
  accum)
(define attempts (make-accum 0))
(define (reset-attempts) (attempts (- (attempts 0))))

(define (make-account balance pass)
  (define (call-cops)
    (display "callinng cops"))
  (define counter (make-accum 0))
  (define (withdraw amount)
    (if (>= balance amount)
        (begin (set! balance (- balance amount))
               balance)
        "Insufficient Funds"))

  (define (deposit amount)
    (set! balance (+ balance amount))
    balance)
  (define (check-auth auth)
    (if (not (eq? auth pass))
        (begin
          (if (> (counter 1) 2) (call-cops))
          #f)

        #t))
  (define (dispatch m auth)
    (if (check-auth auth)
        (cond ((eq? m 'withdraw) withdraw)
              ((eq? m 'deposit) deposit)
              (else (error 'unknown request ' m)))
        (lambda (x) (display 'invalid-auth) 0)))

  dispatch)

(define acc (make-account 100 'rosebud))

(define (make-joint acc orig-pass joint-pass)
  (define (invalid . x)
    (display 'invalid)
    (pair? x)
    (car x)
    )
  (define (dispatch m auth)
    (if (eq? auth joint-pass) (acc m orig-pass)
        invalid
        ))
  dispatch)

(define jacc (make-joint acc 'rosebud 'foobud))
((jacc 'withdraw 'foobud) 10)

;; (newline)
;;((acc 'withdraw 'rosebud) 50)
;;((acc 'withdraw 'foobud) 50)
;; (display ((acc 'withdraw) 60))
;; ((acc 'deposit) 60)
;; ((acc 'withdraw) 60)


;; (define A (make-accum 5))

;; (define (make-monitored proc)
;;   (let ((times 0))
;;     (define (run . args)
;;       (set! times (+ times 1))
;;       (display 'times)(display times)(newline)
;;       (display args)(newline)
;;       (apply proc args)
;;       )
;;     (define (dispatch m)
;;       (cond ((eq? m 'how-many) (display 'run)(display times))
;;             (else (run m))))
;;     dispatch))

;; (define s (make-monitored square))
;; (s 10)
(define (make-parameter x)
  x)
(define modulus (expt 2 64))
(define multiplier 6364136223846793005)
(define increment 1442695040888963407)

;; (define (rand-update x)
;;   (modulo (+ (* multiplier x) increment) modulus))
(define (cesaro-test)
  (= (gcd (random 10000) (random 10000)) 1))
(define (estimate-pi trials)
  (sqrt (/ 6 (monte-carlo trials cesaro-test))))
(define (monte-carlo trials experiment)
  (define (iter trials-remaining trials-passed)
    (cond ((= trials-remaining 0)
           (/ trials-passed (* trials 1.0)))
          ((experiment)
           (iter (- trials-remaining 1) (+ trials-passed 1)))
          (else
           (iter (- trials-remaining 1) trials-passed))))
  (iter trials 0))

(define (random-in-range low high)
  (let ((range (- high low)))
    (+ low (random range))))
(define pi 3.14159265359)
(define (P x y)
  (< (+ (expt (- x 5) 2)
        (expt (- y 7) 2))
     (expt 3 2)))
(define (mypred? x y)
  ;;(display 'x)(display x)(newline)
  ;;(x - 5)2 + (y - 7)2< 32
  (> (square 3) (+ (square (- x 5)) (square (- y 7)))))
(define (make-test pred? x1 x2 y1 y2)
  ;;  (lambda ()
  (pred? (random-in-range x1 x2) (random-in-range y1 y2)))
;;    )

(define (estimate-pi-2 trials radius)
  (/ (* (area-of-rect 2 8 4 10) (estimate-integral2 mypred?  2.0 8.0 4.0 10.0 trials)) (square radius)))

(define (area-of-rect x1 x2 y1 y2)
  (* (- x2 x1) (- y2 y1)))
;; (define (estimate-integral P x1 x2 y1 y2 trials)
;;   (define (exp)
;;     (make-test P x1 x2 y1 y2))
;;   (monte-carlo trials exp))
(define (estimate-integral2 P x1 x2 y1 y2 trials)
  (define (region-test)
    (let ((x (random-in-range x1 x2))
          (y (random-in-range y1 y2)))
      (P x y)))
  (monte-carlo trials region-test))
(define (pi-approx2)
  (/ (* 36 (estimate-integral2 mypred? 2.0 8.0 4.0 10.0 1000000)) 9))
(define (main)
  (format "New Hello, ~a" "World!"))

((jacc 'withdraw 'foobud) 10)
;;(estimate-pi-2 4 3)

(define (tricky)
  (let ((evaluated #f))
    (lambda (x)
      (display evaluated)(newline)
      (if evaluated 0
          (begin (set! evaluated #t)
                 x)))))

(define f1 (tricky))
(define f2 (tricky))

(define (ltr)
(let ((l (f1 0))(r (f1 1)))
  (display (+ l r))))


(define (rtl)
(let ((l (f1 1))(r (f1 0)))
  (display (+ l r))))
