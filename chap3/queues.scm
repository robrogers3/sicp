(define (make-queue)
  (cons '() '()))
(define (make-pair data)
  (cons data '()))
(define (front-ptr queue)
  (car queue))
(define (rear-ptr queue)
  (cdr queue))
(define (set-front-ptr! queue item)
  (set-car! queue item))
(define (set-rear-ptr! queue item)
  (set-cdr! queue item))
(define (empty-queue? queue)
  (null? (front-ptr queue)))
(define (front-queue queue)
  (if (empty-queue? queue)
      (error "FRONT-QUEUE called on empty queue" queue)
      (car (front-ptr queue))))
(define (insert-queue! queue item)
  (let ((new-pair (make-pair item)))
    (cond ((empty-queue? queue)
	   (set-front-ptr! queue new-pair)
	   (set-rear-ptr! queue new-pair)
	   queue)
	  (else
	   ;;rear pts to pair [data|/]
	   (set-cdr! (rear-ptr queue) new-pair)
	   ;;[data| ]->[newdat|/a]
	   (set-rear-ptr! queue new-pair)
	   queue))))

;;ft-ptr -> [v][ptr]
(define (delete-queue! queue)
  (cond ((empty-queue? queue)
	 (error "cannot call delete on empty queue" queue))
	(else
	 (set-front-ptr! queue (cdr (front-ptr queue)))
	 queue)))


(define (print-queue queue)
  (define (iter item)
    (if (null? item) 'done
	(begin 
	  (display (car item))(newline)
	  (iter (cdr item)))))
  (iter (front-ptr queue)))


(define q1 (make-queue))
(insert-queue! q1 'a)
(insert-queue! q1 'b)
(delete-queue! q1)
(insert-queue! q1 'c)
;;(delete-queue! q1)

(define (make-que)
  (let* ((front-ptr '())
	 (rear-ptr '()))
    (define (set-front-ptr! x)
      (set! front-ptr x))
    (define (set-rear-ptr! x)
      (set! rear-ptr x))
    (define (empty-q?)
      (null? front-ptr))
    (define (front-queue)
      (if (empty-queue? queue)
	  (error "FRONT called with an empty queue" queue)
	  (car front-ptr)))
    (define (insert-q x)
      (let ((new-pair (cons x '())))
	(cond ((empty-q?)
	       (set-front-ptr! new-pair)
	       (set-rear-ptr! new-pair))
	      (else
	       (set-cdr! rear-ptr new-pair)
	       (set-rear-ptr! new-pair)))
	front-ptr))
    (define (delete-q)
      (if (empty-q?)
	  (error "FRONT called with an empty queue")
	  (set-front-ptr! (cdr front-ptr)))
      front-ptr
      )
    
    (define (print-q)
      (display q))
    (define (dispatch m)
      (cond
       ((eq? m 'insert) insert-q)
       ((eq? m 'delete) delete-q)
       ((eq? m 'print)  print-q)
       (else
	(error "invalid meassage", m))))
    dispatch))

;;(define qq (make-que))

(define (make-deque)
  (cons '() '()))
(define (make-node data)
  (cons data (cons '() '())))
(define (front-ptr deque)
  (car deque))
(define (rear-ptr deque)
  (cdr deque))
(define (set-front-ptr! deque item)
  (set-car! deque item))
(define (set-rear-ptr! deque item)
  (set-cdr! deque item))
(define (empty-deque? deque)
  (null? (front-ptr deque)))
(define (front-deque deque)
  (if (empty-deque?)
      (error "FRONT DEQUE called on empty deque")
      (car (front-ptr deque))))
(define (rear-deque deque)
  (if (empty-deque?)
      (error "REAR DEQUE called on empty deque")
      (car (rear-ptr deque)))) ;; front (), rear (car, cdr); t

(define (set-prev! node target-node)
  (set-car! (cdr node) target-node))
(define (set-next! node target-node)
  (set-cdr! (cdr node) target-node))
(define (front-insert-deque! deque item)
  (let ((new-node (make-node item)))
    (cond
     ((empty-deque? deque)
      (set-front-ptr! deque new-pair)
      (set-rear-ptr! deque new-pair))
     (else
      (set-next! new-node (front-ptr deque))
      (set-prev! (front-ptr deque) new-node)
      (set-front-ptr! deque new-node)))))
(define (rear-insert-deque! deque item)
  (let ((new-node (make-node item)))
    (cond
     ((empty-deque? deque)
      (set-front-ptr! deque new-node)
      (set-rear-ptr! deque new-node))
     (else
      ;;set cdr of cdr current rear (rear-ptr) to next (node)
      (set-next! (rear-ptr deque) new-node)
      ;;set car of cdr new node to cadr  (prev) to rear-ptr
      (set-prev! new-node (rear-ptr deque))
      ;;set set-rear-ptr to new node
      (set-rear-ptr! deque new-node)
      ))))

(define dq1 (make-deque))
(define n1 (make-node 'a))
(define n2 (make-node 'b))
(define n3 (make-node 'b))
(define n4 (cons 'data (cons 'p1 'p2)))
(define lnk1 (cons 'prev 'next))
(rear-insert-deque! dq1 'b)
(rear-insert-deque! dq1 'c)
(front-insert-deque! dq1 'a)

(define (make-deque) (cons nil nil)) 
(define (front-ptr deque) (car deque)) 
(define (rear-ptr deque) (cdr deque)) 
(define (empty-deque? deque) (null? (front-ptr deque))) 
(define (set-front! deque item) (set-car! deque item)) 
(define (set-rear! deque item) (set-cdr! deque item)) 

(define (get-item deque end) 
  (if (empty-deque? deque) 
      (error "Trying to retrieve item from empty deque" deque) 
      (caar (end deque)))) 

(define (insert-deque! deque item end) 
  (let ((new-pair (cons (cons item nil) nil))) 
    (cond ((empty-deque? deque) 
           (set-front! deque new-pair) 
           (set-rear! deque new-pair)) 
          ((eq? end 'front) 
           (set-cdr! new-pair (front-ptr deque)) 
           (set-cdr! (car (front-ptr deque)) new-pair) 
           (set-front! deque new-pair)) 
          (else (set-cdr! (rear-ptr deque) new-pair) 
                (set-cdr! (car new-pair) (rear-ptr deque)) 
                (set-rear! deque new-pair))))) 

(define (front-delete-deque deque) 
  (cond ((empty-deque? deque) (error "Cannot delete from empty deque" deque)) 
        (else (set-front! deque (cdr (front-ptr deque))) 
              (or (empty-deque? deque) (set-cdr! (car (front-ptr deque)) nil))))) 

(define (rear-delete-deque deque) 
  (cond ((empty-deque? deque) (error "Cannot delete from empty deque" deque)) 
        (else (set-rear! deque (cdar (rear-ptr deque))) 
              (if (null? (rear-ptr deque)) (set-front! deque nil) 
                  (set-cdr! (rear-ptr deque) nil))))) 

(define (front-insert-deque! deque item) (insert-deque! deque item 'front)) 
(define (rear-insert-deque! deque item) (insert-deque! deque item 'rear)) 
(define (front-deque deque) (get-item deque front-ptr)) 
(define (rear-deque deque) (get-item deque rear-ptr)) 

(define (print-deque d) 
  (define (iter res _d) 
    (if (or (null? _d) (empty-deque? _d)) res 
	(iter (append res (list (caaar _d))) (cons (cdar _d) (cdr d))))) 
  (iter nil d)) 

(define dq2 (make-deque))
;; (rear-insert-deque! dq2 'a)
;; (rear-insert-deque! dq2 'b)

;;nodes
(define (make-node data)
  (cons data (cons '() '())))
(define (node-data node)
  (car node))
(define (next-node node)
  (cddr node))
(define (prev-node node)
  (cadr node))
(define (set-prev-node! node target-node)
  (set-car! (cdr node) target-node))
(define (set-next-node! node target-node)
  (set-cdr! (cdr node) target-node))
(define (nuke-node node)
  (set-cdr! node '()))
;;deque
(define (make-deque)
  (cons '() '()))
(define (front-ptr deque)
  (car deque))
(define (rear-ptr deque)
  (cdr deque))
(define (set-front-pointer! deque node)
  (set-car! deque node))
(define (set-rear-pointer! deque node)
  (set-cdr! deque node))
(define (empty-deque? deque)
  (null? (front-ptr deque)))
(define (front-deque deque)
  (if (empty-deque? deque)
      (error "FRONT DEQUE called on empty deque")
      (node-data (front-ptr deque))))
(define (rear-deque deque)
  (if (empty-deque? deque)
      (error "REAR DEQUE called on empty deque")
      (node-data (rear-ptr deque))))
(define (front-insert-deque! deque data)
  (let ((new-node (make-node data)))
    (cond
     ((empty-deque? deque)
      (set-front-ptr! deque new-node)
      (set-rear-ptr! deque new-node))
     (else
      (set-next-node! new-node (front-ptr deque))
      (set-prev-node! (front-ptr deque) new-node)
      (set-front-ptr! deque new-node)))))
(define (rear-insert-deque! deque data)
  (let ((new-node (make-node data)))
    (cond
     ((empty-deque? deque)
      (set-front-ptr! deque new-node)
      (set-rear-ptr! deque new-node))
     (else
      (set-prev-node! new-node (rear-ptr deque))
      (set-next-node! (rear-ptr deque) new-node)
      (set-rear-ptr! deque new-node)))))
(define (front-delete-deque deque)
  (cond ((empty-deque? deque)
	 (error "front-delete called on empty deque" deque))
	((eq? (front-ptr deque) (rear-ptr deque))
	 (set-front-ptr! deque '())
	 (set-rear-ptr! deque '()))
	(else
	 (let ((node-next (next-node (front-ptr deque))))
	   (set-prev-node! node-next '())
	   (set-front-ptr! deque node-next)
	   ))))
(define (rear-delete-deque deque)
  (cond ((empty-deque? deque)
	 (error "rear-delete-deque called on empty deque" deque))
	((eq? (front-ptr deque) (rear-ptr deque))
	 (set-front-ptr! '())
	 (set-rear-ptr! '()))
	(else
	 (let ((node-prev (prev-node (rear-ptr deque))))
	   (set-next-node! node-prev '())
	   (set-rear-ptr! deque node-prev)
	   ))))
(define (print-deque deque)
  (define (iter node)
    (if (null? node) 'doneprint
	(begin
	  (display (node-data node))(newline)
	  (iter (next-node node)))))
  (if (empty-deque? deque)
      'empty-deque
      (iter (front-ptr deque))))

(define dq3 (make-deque))
(rear-insert-deque! dq3 'b)
(rear-insert-deque! dq3 'c)
(front-insert-deque! dq3 'a)
(display 
 (front-deque dq3))
(newline)
(print-deque dq3)
;; (newline)
;; (rear-delete-deque dq3)
;; (print-deque dq3)
;; (newline)
;; (front-delete-deque dq3)
;; (print-deque dq3)
;; (newline)
;;(front-delete-deque dq3)
;;(print-deque dq3)
;; (accumulate append '() (map (lambda (node)
;; 			      (if (not (null? node))
;; 				  (node-data node))
;; 			      'nope) dq3))
(define (make-dque)
  (let ((front-ptr '())
	(rear-ptr '()))
    (define (set-front-ptr! node)
      (set! front-ptr node))
    (define (set-rear-ptr! node)
      (set! rear-ptr node))
    (define (empty-deque?)
      (null? front-ptr))
    (define (front-deque)
      (if (empty-deque?)
	  (error "FRONT DEQUE called on empty deque")
	  (node-data front-ptr)))
    (define (rear-deque)
      (if (empty-deque?)
	  (error "REAR DEQUE called on empty deque")
	  (node-data rear-ptr)))
    (define (front-insert-deque! data)
      (let ((new-node (make-node data)))
	(cond ((empty-deque?)
	       (set-front-ptr! new-node)
	       (set-rear-ptr! new-node))
	      (else
	       (set-next-node! new-node front-ptr)
	       (set-prev-node! front-ptr new-node)
	       (set-front-ptr! new-node)))))
    (define (rear-insert-deque! data)
      (let ((new-node (make-node data)))
	(cond ((empty-deque?)
	       (set-front-ptr! new-node)
	       (set-rear-ptr! new-node))
	      (else
	       (set-prev-node new-node rear-ptr)
	       (set-next-node! rear-ptr new-node)
	       (set-rear-ptr! new-node)))))
    (define (front-delete-deque!)
      (cond ((empty-deque?)
	     (error "front-delete called on empty deque"))
	    ((eq? front-ptr rear-ptr)
	     (set! front-ptr '())
	     (set! rear-ptr '()))
	    (else
	     (let ((node-next (next-node front-ptr)))
	       (nuke-node! front-ptr)
	       (set-prev-node! node-next '())
	       (set-front-ptr! node-next)))))
    (define (rear-delete-deque!)
            (cond ((empty-deque?)
	     (error "rear-delete called on empty deque"))
	    ((eq? front-ptr rear-ptr)
	     (set! front-ptr '())
	     (set! rear-ptr '()))
	    (else
	     (let ((node-prev (prev-node rear-ptr)))
	       (nuke-node! rear-ptr)
	       (set-next-node! node-prev '())
	       (set-rear-ptr! node-prev)))))
    (define (print-deque)
      (let ((ptr front-ptr))
	(define (iter node)
	  (if (null? node)
	      'done
	      (begin 
	  (display (node-data node))(newline)
	  (iter (next-node node)))))
	(iter ptr)))
	  
    (define (dispatch m)
      (cond ((eq? m 'empty-queue? )  empty-deque?)
            ((eq? m 'front-insert-queue!) front-insert-deque!)
            ((eq? m 'rear-insert-queue!) rear-insert-deque!)
            ((eq? m 'front-delete-queue!) front-delete-deque!)
            ((eq? m 'rear-delete-queue!) rear-delete-deque!)
            ((eq? m 'front-queue  )   front-deque)
	    ((eq? m 'rear-queue  )   rear-deque)
            ((eq? m 'print-queue  )   print-deque)
            (else (error "ERROR invalid command " m))))
    dispatch))



(define q4 (make-dque))
(define (front-insert-dq! q item)
  ((q 'front-insert-queue!) item))
(define (print-q q)
  ((q 'print-queue)))
