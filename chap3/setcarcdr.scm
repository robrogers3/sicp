(define (last-pair x)
  (if (null? (cdr x))
      x
      (last-pair (cdr x))))

(define (append! x y)
  (set-cdr! (last-pair x) y)
  x)
(define p (cons 1 2))
(define x (list 'a 'b))
(define y (list 'c 'd))
(define z1 (cons x x))
(define z2 (cons (list 'a 'b) (list 'a 'b)))
;;(define z (append! x y))
;;(define w (append! x y))
(define (cnns a b)
  (lambda (m) (m a b)))


(define (make-cycle x)
  (set-cdr! (last-pair x) x)
  x)

(define (mystery x)
  (define (loop x y)
    (display x)(newline)
    (if (null? x)
        y
        (let ((temp (cdr x)))
	  (display 'temp)(display temp)(newline)
	  
	  (display 'y)(display y)(newline)
          (set-cdr! x y)
	  (display 'x)(display x)(newline)
          (loop temp x))))
  (loop x '()))
(define (mystery x)
  (define (loop x y)
    (if (null? x)
        y
        (let ((temp (cdr x)))
          (set-cdr! x y)
          (loop temp x))))
  (loop x '()))
(define (set-to-wow x)
  (set-car! (car x) 'wow)
  x)
(define v (list 'a 'b 'c 'd))
(define w (mystery v))
(define (wrong-count-pairs x)
  (if (not (pair? x)) 0
      (+ (wrong-count-pairs (car x))
	 (wrong-count-pairs (cdr x)) 1)
      ))
(define (zap x)
  (with-output-to-string (lambda () (write/ss x))))
(define (make-cycle x)
  (set-cdr! (last-pair x) x)
  x)

(define z3 (list 'a 'b 'c))
(define z4
  (let ((x (list 'a)))
    (list x x)))
(define z7
  (let ((x (list 'a))
        (y (cons x x)))
    (cons y y)))
(define z* (make-cycle (list 'a 'b 'c)))
(define (count-pairs x)
  (define visited '())
  (define (go x)
    (if (and (pair? x) (not (memq x visited)))
	(begin
          (set! visited (cons x visited))
          (+ (go (car x))
             (go (cdr x))
             1))
	0))
  (go x))

(define (zap x)
  (with-output-to-string (lambda () (write/ss x))))
(define (count-pairs x)
  ;;  (define visited '())
  (define (go x visited)
    (if (and (pair? x) (not (memq x visited)))
	(begin
	  ;;(set! visited (cons x visited))
	  (+ (go (car x) (cons x visited))
	     (go (cdr x) (cons x visited))
	     1)
	  )
	0))
  (go x '())
  )
(define (count-pairs-snu x)
  (let go ((x x)
           (visited '()))
    (if (and (pair? x) (not (memq x visited)))
        (let* ((p-car (go (car x) (cons x visited)))
               (p-cdr (go (cdr x) (cdr p-car))))
	  (display p-car)(newline)
          (cons (+ (car p-car) (car p-cdr) 1) (cdr p-cdr)))
        (cons 0 visited))))

(define (circular? items)
  (define visited '())
  (define (go x visited)
    (if (pair? x)
	(cond ((memq x visited) #t)
	      (else (set! visited (cons x visited)) (go (cdr x) (cons x visited))))
	#f)
    )
  (go items '())
  )

(define (next-pair pair)
  (if (pair? pair)
      (cdr pair)
      #f))

(define (circular? x)
  (define (next x)
    (if (pair? x)
	(cdr x)
	#f))
  (let go ((x1 x)
           (x2 (next x)))
    (if (and x1 x2)
	(if (eq? x1 x2)
            #t
            (go (next x1) (next (next x2))))
	#f)))



(define (circular? x)
  (define (next x)
    (if (pair? x)
	(cdr x)
	#f))
  (let go ((x1 x)
           (x2 (next x)))
    (if (and x1 x2)
	(if (eq? x1 x2)
            #t
            (go (next x1) (next (next x2))))
	#f))
  )


(define (contains-cycle? lst) 
  (define (safe-cdr l) 
    (if (pair? l) 
        (cdr l) 
        '())) 
  (define (iter a b) 
    (cond ((not (pair? a)) #f) 
          ((not (pair? b)) #f) 
          ((eq? a b) #t) 
          ((eq? a (safe-cdr b)) #t) 
          (else (iter (safe-cdr a) (safe-cdr (safe-cdr b)))))) 
  (iter (safe-cdr lst) (safe-cdr (safe-cdr lst))))
(define (cycle? lst)
  (define (safe-cdr l)
    (if (pair? l)
	(cdr l)
	'()))
  (define (iter a b)
    (cond
     ((not (pair? a)) #f)
     ((not (pair? b)) #f)
     ((eq? a b) #t)
     ((eq? a (safe-cdr b)) #t)
     (else
      (iter (safe-cdr a) (safe-cdr (safe-cdr b))))))
  (iter list (safe-cdr list)))


(define (circular x)
  (define (next l)
    (if (pair? l)
	(cdr l)
	'()))
  (define (go x1 x2)
    (cond ((not (pair? x1)) #f)
	  ((not (pair? x2)) #f)
	  ((eq? x1 x2) #t)
	  ((eq? x1 (next x2)) #t)
	  (else
	      (go (next x1) (next (next x2))))))
  (go x (next x)))

(define (cnns x y)
  (define (dispatch m)
    (cond ((eq? m 'car) x)
	  ((eq? m 'cdr) y)
	  (else
	   "undefined cnns op")))
  dispatch)

(define (carr z) (z 'car))
(define (cdrr z) (z 'cdr))
